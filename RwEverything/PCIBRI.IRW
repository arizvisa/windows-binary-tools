[INFO]
00 = Vendor ID - Offset [1:0]\r\rThe Vendor ID register identifies the manufacturer of the device and is assigned by PCISIG to insure uniqueness.
01 = Vendor ID - Offset [1:0]\r\rThe Vendor ID register identifies the manufacturer of the device and is assigned by PCISIG to insure uniqueness.
02 = Device ID - Offset [3:2]\r\rThe Device ID register identifies the particular device and is assigned by the vendor.
03 = Device ID - Offset [3:2]\r\rThe Device ID register identifies the particular device and is assigned by the vendor.
04 = Command - Offset [5:4]\r B0 - I/O Space Enable\r B1 - Memory Space Enable\r B2 - Bus Master Enable\r B3 - Special Cycle Enable\r B4 - Memory Write and Invalidate\r B5 - VGA Palette Snoop Enable\r B6 - Parity Error Response\r B7 - Reserved\r B8 - SERR# Enable\r B9 - Fast Back-to-Back Enable\r B10 - Interrupt Disable\r B15:11 - Reserved
05 = Command - Offset [5:4]\r B0 - I/O Space Enable\r B1 - Memory Space Enable\r B2 - Bus Master Enable\r B3 - Special Cycle Enable\r B4 - Memory Write and Invalidate\r B5 - VGA Palette Snoop Enable\r B6 - Parity Error Response\r B7 - Reserved\r B8 - SERR# Enable\r B9 - Fast Back-to-Back Enable\r B10 - Interrupt Disable\r B15:11 - Reserved
06 = Status - Offset [7:6]\r B2:0 - Reserved\r B3 - Interrupt Status\r B4 - Capabilities List\r B5 - 66 MHz Capable\r B6 - Reserved\r B7 - Fast Back-to-Back Capable\r B8 - Master Data Parity Error\r B10:9 - DEVSEL# Timing\r  00 - fast\r  01 - medium\r  02 - slow\r B11 - Signaled Target-Abort\r B12 - Received Target-Abort\r B13 - Received Master-Abort\r B14 - Signaled System Error\r B15 - Detected Parity Error
07 = Status - Offset [7:6]\r B2:0 - Reserved\r B3 - Interrupt Status\r B4 - Capabilities List\r B5 - 66 MHz Capable\r B6 - Reserved\r B7 - Fast Back-to-Back Capable\r B8 - Master Data Parity Error\r B10:9 - DEVSEL# Timing\r  00 - fast\r  01 - medium\r  02 - slow\r B11 - Signaled Target-Abort\r B12 - Received Target-Abort\r B13 - Received Master-Abort\r B14 - Signaled System Error\r B15 - Detected Parity Error
08 = Revision ID\r\rThe Revision ID register specifies a device-specific revision identifier.
09 = Class code - Programming Interface type\r\rThe Class Code register is used to identify the function of the device.
0A = Class code - Sub type\r\rThe Class Code register is used to identify the function of the device.
0B = Class code - Base type\r\rThe Class Code register is used to identify the function of the device.
0C = Cache line size\r\rThe Cacheline Size register is used when terminating a transaction that uses the Memory Write and Invalidate command and when prefetching (Memory Read Line and Memory Read Multiple commands).
0D = Primary Latency timer\r\rThe Latency Timer register is required if a bridge is capable of a burst transfer of more than two data phases on its primary interface.
0E = Header type\r 00 - Standard PCI\r 01 - PCI-to-PCI Bridge\r 02 - Cardbus\r B7 = 1 - Multi-Function Device
0F = Built-In Self Test\r B3:0 - BIST Result\r B5:4 - Reserved\r B6 - Start BIST\r B7 - BIST Capable
10 = Base Address 0 - Offset [13:10]\r\r Memory Base\r  B0 = 0 - Memory space\r  B2:1 - Type\r   00 - Base address is 32 bits wide\r   01 - Reserved\r   10 - Base address is 64 bits wide\r   11 - Reserved\r  B3 = 1 - Memory is prefetchable\r  B31:4 - Base address\r\r I/O Base\r  B0 = 1 - I/O space\r  B1 - Reserved\r  B31:2 - Base address
11 = Base Address 0 - Offset [13:10]\r\r Memory Base\r  B0 = 0 - Memory space\r  B2:1 - Type\r   00 - Base address is 32 bits wide\r   01 - Reserved\r   10 - Base address is 64 bits wide\r   11 - Reserved\r  B3 = 1 - Memory is prefetchable\r  B31:4 - Base address\r\r I/O Base\r  B0 = 1 - I/O space\r  B1 - Reserved\r  B31:2 - Base address
12 = Base Address 0 - Offset [13:10]\r\r Memory Base\r  B0 = 0 - Memory space\r  B2:1 - Type\r   00 - Base address is 32 bits wide\r   01 - Reserved\r   10 - Base address is 64 bits wide\r   11 - Reserved\r  B3 = 1 - Memory is prefetchable\r  B31:4 - Base address\r\r I/O Base\r  B0 = 1 - I/O space\r  B1 - Reserved\r  B31:2 - Base address
13 = Base Address 0 - Offset [13:10]\r\r Memory Base\r  B0 = 0 - Memory space\r  B2:1 - Type\r   00 - Base address is 32 bits wide\r   01 - Reserved\r   10 - Base address is 64 bits wide\r   11 - Reserved\r  B3 = 1 - Memory is prefetchable\r  B31:4 - Base address\r\r I/O Base\r  B0 = 1 - I/O space\r  B1 - Reserved\r  B31:2 - Base address
14 = Base Address 1 - Offset [17:14]\r\r Memory Base\r  B0 = 0 - Memory space\r  B2:1 - Type\r   00 - Base address is 32 bits wide\r   01 - Reserved\r   10 - Base address is 64 bits wide\r   11 - Reserved\r  B3 = 1 - Memory is prefetchable\r  B31:4 - Base address\r\r I/O Base\r  B0 = 1 - I/O space\r  B1 - Reserved\r  B31:2 - Base address
15 = Base Address 1 - Offset [17:14]\r\r Memory Base\r  B0 = 0 - Memory space\r  B2:1 - Type\r   00 - Base address is 32 bits wide\r   01 - Reserved\r   10 - Base address is 64 bits wide\r   11 - Reserved\r  B3 = 1 - Memory is prefetchable\r  B31:4 - Base address\r\r I/O Base\r  B0 = 1 - I/O space\r  B1 - Reserved\r  B31:2 - Base address
16 = Base Address 1 - Offset [17:14]\r\r Memory Base\r  B0 = 0 - Memory space\r  B2:1 - Type\r   00 - Base address is 32 bits wide\r   01 - Reserved\r   10 - Base address is 64 bits wide\r   11 - Reserved\r  B3 = 1 - Memory is prefetchable\r  B31:4 - Base address\r\r I/O Base\r  B0 = 1 - I/O space\r  B1 - Reserved\r  B31:2 - Base address
17 = Base Address 1 - Offset [17:14]\r\r Memory Base\r  B0 = 0 - Memory space\r  B2:1 - Type\r   00 - Base address is 32 bits wide\r   01 - Reserved\r   10 - Base address is 64 bits wide\r   11 - Reserved\r  B3 = 1 - Memory is prefetchable\r  B31:4 - Base address\r\r I/O Base\r  B0 = 1 - I/O space\r  B1 - Reserved\r  B31:2 - Base address
18 = Primary bus number\r\rThe Primary Bus Number register is used to record the bus number of the PCI bus segment to which the primary interface of the bridge is connected.
19 = Secondary bus number\r\rThe Secondary Bus Number register is used to record the bus number of the PCI bus segment to which the secondary interface of the bridge is connected.
1A = Subordinate bus number\r\rThe Subordinate Bus Number register is used to record the bus number of the highest numbered PCI bus segment which is behind (or subordinate to) the bridge.
1B = Secondary latency timer\r\rThe Latency Timer register is required if a bridge is capable of a burst transfer of more than two data phases on its secondary interface.
1C = I/O base\r\rThe I/O Base and I/O Limit registers are optional and define an address range that is used by the bridge to determine when to forward I/O transactions from one interface to the other.\r\r B3:0 - I/O Addressing Capability\r  00 - 16-bit I/O addressing\r  01 - 32-bit I/O addressing\r  02-0F - Reserved\r B7:4 - I/O base AD[15:12]\r  AD[11:0] = 000
1D = I/O limit\r\rThe I/O Base and I/O Limit registers are optional and define an address range that is used by the bridge to determine when to forward I/O transactions from one interface to the other.\r\r B3:0 - I/O Addressing Capability\r  00 - 16-bit I/O addressing\r  01 - 32-bit I/O addressing\r  02-0F - Reserved\r B7:4 - I/O limit AD[15:12]\r  AD[11:0] = FFF
1E = Secondary status - Offset [1F:1E]\r B4:0 - Reserved\r B5 - 66 MHz Capable\r B6 - Reserved\r B7 - Fast Back-to-Back Capable\r B8 - Master Data Parity Error\r B10:9 - DEVSEL# Timing\r  00 - fast\r  01 - medium\r  02 - slow\r B11 - Signaled Target-Abort\r B12 - Received Target-Abort\r B13 - Received Master-Abort\r B14 - Signaled System Error\r B15 - Detected Parity Error
1F = Secondary status - Offset [1F:1E]\r B4:0 - Reserved\r B5 - 66 MHz Capable\r B6 - Reserved\r B7 - Fast Back-to-Back Capable\r B8 - Master Data Parity Error\r B10:9 - DEVSEL# Timing\r  00 - fast\r  01 - medium\r  02 - slow\r B11 - Signaled Target-Abort\r B12 - Received Target-Abort\r B13 - Received Master-Abort\r B14 - Signaled System Error\r B15 - Detected Parity Error
20 = Memory base - Offset [21:20]\r\rThe Memory Base and Memory Limit registers are both required registers that define a memory mapped I/O address range which is used by the bridge to determine when to forward memory transactions from one interface to the other.\r\r B3:0 - Reserved\r B15:4 - Memory base AD[31:20]\r  AD[19:0] = 00000
21 = Memory base - Offset [21:20]\r\rThe Memory Base and Memory Limit registers are both required registers that define a memory mapped I/O address range which is used by the bridge to determine when to forward memory transactions from one interface to the other.\r\r B3:0 - Reserved\r B15:4 - Memory base AD[31:20]\r  AD[19:0] = 00000
22 = Memory limit - Offset [23:22]\r\rThe Memory Base and Memory Limit registers are both required registers that define a memory mapped I/O address range which is used by the bridge to determine when to forward memory transactions from one interface to the other.\r\r B3:0 - Reserved\r B15:4 - Memory limit AD[31:20]\r  AD[19:0] = FFFFF
23 = Memory limit - Offset [23:22]\r\rThe Memory Base and Memory Limit registers are both required registers that define a memory mapped I/O address range which is used by the bridge to determine when to forward memory transactions from one interface to the other.\r\r B3:0 - Reserved\r B15:4 - Memory limit AD[31:20]\r  AD[19:0] = FFFFF
24 = Prefetchable memory base\r   - Offset [25:24]\r\rThe Prefetchable Memory Base and Prefetchable Memory Limit registers are optional. They define a prefetchable memory address range which is used by the bridge to determine when to forward memory transactions from one interface to the other.\r\r B3:0 - Reserved\r B15:4 - Memory base AD[31:20]\r  AD[19:0] = 00000
25 = Prefetchable memory base\r   - Offset [25:24]\r\rThe Prefetchable Memory Base and Prefetchable Memory Limit registers are optional. They define a prefetchable memory address range which is used by the bridge to determine when to forward memory transactions from one interface to the other.\r\r B3:0 - Reserved\r B15:4 - Memory base AD[31:20]\r  AD[19:0] = 00000
26 = Prefetchable memory limit\r   - Offset [27:26]\r\rThe Prefetchable Memory Base and Prefetchable Memory Limit registers are optional. They define a prefetchable memory address range which is used by the bridge to determine when to forward memory transactions from one interface to the other.\r\r B3:0 - Reserved\r B15:4 - Memory limit AD[31:20]\r  AD[19:0] = FFFFF
27 = Prefetchable memory limit\r   - Offset [27:26]\r\rThe Prefetchable Memory Base and Prefetchable Memory Limit registers are optional. They define a prefetchable memory address range which is used by the bridge to determine when to forward memory transactions from one interface to the other.\r\r B3:0 - Reserved\r B15:4 - Memory limit AD[31:20]\r  AD[19:0] = FFFFF
28 = Prefetchable base upper 32 bits\r   - Offset [2B:28]\r\rThe Prefetchable Base Upper 32 Bits and Prefetchable Limit Upper 32 Bits registers are optional extensions to the Prefetchable Memory Base and Prefetchable Memory Limit registers.
29 = Prefetchable base upper 32 bits\r   - Offset [2B:28]\r\rThe Prefetchable Base Upper 32 Bits and Prefetchable Limit Upper 32 Bits registers are optional extensions to the Prefetchable Memory Base and Prefetchable Memory Limit registers.
2A = Prefetchable base upper 32 bits\r   - Offset [2B:28]\r\rThe Prefetchable Base Upper 32 Bits and Prefetchable Limit Upper 32 Bits registers are optional extensions to the Prefetchable Memory Base and Prefetchable Memory Limit registers.
2B = Prefetchable base upper 32 bits\r   - Offset [2B:28]\r\rThe Prefetchable Base Upper 32 Bits and Prefetchable Limit Upper 32 Bits registers are optional extensions to the Prefetchable Memory Base and Prefetchable Memory Limit registers.
2C = Prefetchable limit upper 32 bits\r   - Offset [2F:2C]\r\rThe Prefetchable Base Upper 32 Bits and Prefetchable Limit Upper 32 Bits registers are optional extensions to the Prefetchable Memory Base and Prefetchable Memory Limit registers.
2D = Prefetchable limit upper 32 bits\r   - Offset [2F:2C]\r\rThe Prefetchable Base Upper 32 Bits and Prefetchable Limit Upper 32 Bits registers are optional extensions to the Prefetchable Memory Base and Prefetchable Memory Limit registers.
2E = Prefetchable limit upper 32 bits\r   - Offset [2F:2C]\r\rThe Prefetchable Base Upper 32 Bits and Prefetchable Limit Upper 32 Bits registers are optional extensions to the Prefetchable Memory Base and Prefetchable Memory Limit registers.
2F = Prefetchable limit upper 32 bits\r   - Offset [2F:2C]\r\rThe Prefetchable Base Upper 32 Bits and Prefetchable Limit Upper 32 Bits registers are optional extensions to the Prefetchable Memory Base and Prefetchable Memory Limit registers.
30 = I/O base upper 16 bits\r   - Offset [31:30]\r\rThe I/O Base Upper 16 Bits and I/O Limit Upper 16 Bits registers are optional extensions to the I/O Base and I/O Limit registers. If the I/O Base and I/O Limit registers indicate support for 16-bit I/O address decoding, then these registers are implemented as read-only registers which return zero when read. If 32-bit I/O addressing is supported, then these registers must be initialized by configuration software so default states are not specified.
31 = I/O base upper 16 bits\r   - Offset [31:30]\r\rThe I/O Base Upper 16 Bits and I/O Limit Upper 16 Bits registers are optional extensions to the I/O Base and I/O Limit registers. If the I/O Base and I/O Limit registers indicate support for 16-bit I/O address decoding, then these registers are implemented as read-only registers which return zero when read. If 32-bit I/O addressing is supported, then these registers must be initialized by configuration software so default states are not specified.
32 = I/O limit upper 16 bits\r   - Offset [33:32]\r\rThe I/O Base Upper 16 Bits and I/O Limit Upper 16 Bits registers are optional extensions to the I/O Base and I/O Limit registers. If the I/O Base and I/O Limit registers indicate support for 16-bit I/O address decoding, then these registers are implemented as read-only registers which return zero when read. If 32-bit I/O addressing is supported, then these registers must be initialized by configuration software so default states are not specified.
33 = I/O limit upper 16 bits\r   - Offset [33:32]\r\rThe I/O Base Upper 16 Bits and I/O Limit Upper 16 Bits registers are optional extensions to the I/O Base and I/O Limit registers. If the I/O Base and I/O Limit registers indicate support for 16-bit I/O address decoding, then these registers are implemented as read-only registers which return zero when read. If 32-bit I/O addressing is supported, then these registers must be initialized by configuration software so default states are not specified.
34 = Capabilities pointer\r\rThis optional register is used to point to a linked list of additional capabilities implemented by this device.
35 = Reserved - Offset [37:35]\r\rRead accesses to these registers must complete normally and return a value of zero after reset. However, if subsequently written, these registers may return an indeterminate value.
36 = Reserved - Offset [37:35]\r\rRead accesses to these registers must complete normally and return a value of zero after reset. However, if subsequently written, these registers may return an indeterminate value.
37 = Reserved - Offset [37:35]\r\rRead accesses to these registers must complete normally and return a value of zero after reset. However, if subsequently written, these registers may return an indeterminate value.
38 = Expansion ROM base Address\r   - Offset [3B:38]\r B0 = 1 - Expansion ROM enabled\r B10:1 - Reserved\r B31:11 - base address
39 = Expansion ROM base Address\r   - Offset [3B:38]\r B0 = 1 - Expansion ROM enabled\r B10:1 - Reserved\r B31:11 - base address
3A = Expansion ROM base Address\r   - Offset [3B:38]\r B0 = 1 - Expansion ROM enabled\r B10:1 - Reserved\r B31:11 - base address
3B = Expansion ROM base Address\r   - Offset [3B:38]\r B0 = 1 - Expansion ROM enabled\r B10:1 - Reserved\r B31:11 - base address
3C = Interrupt line\r\rThe Interrupt Line register is a read/write register used to communicate interrupt line routing information between initialization code and the device driver. This register must be initialized by initialization code so a default state is not specified. The value written to the Interrupt Line register specifies the routing of the device¡¦s INTx# pin to the system interrupt controller.
3D = Interrupr pin\r\rThe Interrupt Pin register is used to indicate which interrupt pin the bridge uses. A value of 1 corresponds to INTA#; a value of 2 corresponds to INTB#; a value of 3 corresponds to INTC#; and a value of 4 corresponds to INTD#.
3E = Bridge control - Offset [3F:3E]\r B0 - Parity Error Response Enable\r B1 - SERR# Enable\r B2 - ISA Enable\r B3 - VGA Enable\r B4 - VGA 16-bit decode\r B5 - Master-Abort Mode\r B6 - Secondary Bus Reset\r B7 - Fast Back-to-Back Enable\r B8 - Primary Discard Timer\r B9 - Secondary Discard Timer\r B10 - Discard Timer Status\r B11 - Discard Timer SERR# Enable\r B15:12 - Reserved
3F = Bridge control - Offset [3F:3E]\r B0 - Parity Error Response Enable\r B1 - SERR# Enable\r B2 - ISA Enable\r B3 - VGA Enable\r B4 - VGA 16-bit decode\r B5 - Master-Abort Mode\r B6 - Secondary Bus Reset\r B7 - Fast Back-to-Back Enable\r B8 - Primary Discard Timer\r B9 - Secondary Discard Timer\r B10 - Discard Timer Status\r B11 - Discard Timer SERR# Enable\r B15:12 - Reserved